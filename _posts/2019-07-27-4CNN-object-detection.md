---
layout: post
title: "4.CNN_4.object detection"
subtitle: "4.CNN_4.object detection"
categories: data
tags: deeplearningai
comments: true
---
# 4. 탐지 알고리즘


## 1. object localization

- backgroiund는 123이 없을때 배경이라고 분류함

<img src="https://i.imgur.com/2k5jFkC.png">

### 이미지에서 자동차의 위치를 알고자 한다면 어떻게?

- softmax 4개를 출력해주는 것 뿐만 아니라
- 좌표4개가 추가적으로 나와줘야함 ( bounding box)

<img src="https://i.imgur.com/wbgwQZd.png">

- 타겟 레이블 y는 벡터가 되는데  p_c는 물체가 있는지 나타내는 확률, 감지하려는 물체의 확률 (배경제외, 배경이면0)
- 다음은 bx~bw 4개가 좌표를 의미한다
- c1,c2,c3는 클래스1 클래스2 클래스3 을 의미한다 (한개만 1을 갖는다)
- 위 예제는 이미지가 단 한개의 물체만 포함 → 따라서 이 물체들중 최대 한가지만 사진에 나타날 수 있음

두번째 예시

- 학습 데이터가 x = 자동차 사진이라고 하면
- pc=1 이고 bx~bw는 바운딩 박스 4개
- 보행자가 아니므로 0 , 차이므로 1, 오토바이가 아니므로 -

세번째예시

- 학습데이터가 배경
- 첫버냬ㅉ는 0
- don`t care (무관항) 나머지 모두 ? ? ? ? ,? ? ? ?

4 마지막으로 신경망에서 정의항 loss fuct 

- 만약 mse를 사용한다면 → 8개의 구성요소를 갖기때문에 y8까지
- 이 손싥밧은 y1이 1일때의 경우이다
- 이 경우는 물체가 존재할때므로

6 다른경우는 y1=0인 경우인데 

- 이 두번째 경우는 모든 나머지 요소들이 무관항이기 때문
- 이 경우 신경써야할 부분은 단지 p_c값을 예측하는 것이 신경망이 얼마나 잘 작동하는지 알 수 있음
- pc가 1,2,3인 경우에는 모든 경우의 로스 값을 계산 할 수있지만 ,,, 0이고 무관항이면  단지 이거만으로 바껭 측정할 숭벗음

- 예시에서는 로그 우도 손실을 사용할 수도 있는데, 예시에서는 쉽게 사용할 수 있게 mse를 사용
- c_1, c_2, c_3중 하나에 대한 softmax unnit의 출력을 사용한다
- 보통 bounding box좌표에는 mse 오차와 같은 것들을 이용하고
- pc에 대해서 로지스틱 회귀 로스를 사용할 수도 있음, 물론 둘다 mse를 사용해도 괜찮음

<img src="https://i.imgur.com/wJWLsw7.png">

- *b*​*x*​​ : 박스의 중심 위치, x 좌표
- *b*​*y*​​ : 박스의 중심 위치, y 좌표

최종 아웃풋 

<img src="https://i.imgur.com/5P1PeCx.png">

<img src="">

## 2. C4W3L02 Landmark Detection

<img src="">

- 사람 이미지를 input으로 넣고 →conVnet에 넣으면 출력 값이 나오는데
- 첫번째는 face? ( 얼굴인지 아닌지)
- 64개의 특성을 하기위해서 64l까지 내려간다 그리고 각각 2개씩 이므로
- 62*2 + 1 개
- → 이것이 얼굴의 감성을 인식하는 첫 단계

마지막 예시는 자세 감지 

- 여기서도 가슴 중앙, 왼쪽 어꺠. 팔꿈치
- 신경망은 사람의 자세에서 각 중요 위치에 표시를 하게 될 것
- 신경망의 출력으로 이 모든 지점의 값이 나오게 되고
- 자세가 나올 것임

- 이것들을 하기위해 중요 특징점들을 정해야함
- lx, ly 은 가슴 ...........

- 특징점은 항상 똑같아야함→ 특징점1은 항상 왼쪽 눈꼬리 , 특징점2는 한상 ㅗ른쪽 눈꼬리..
- 순서도 항상 같아야함

## 3. object detection

(sliding window detection)

 - 슬라이딩 윈도 알고리즘

![](_2019-07-24__6-339ebc21-4bcb-4986-bb4c-83380ea41440.03.06.png)

![](_2019-07-24__6-73d2c0d7-6a5b-40ce-be8a-2b86b15da83b.09.19.png)

- 특정 윈도 크기를 정하고
- 컨브넷에 이 작은 상자를 입력해
- 컨브넷은 예측 값을 뽑을 것
- 아마도 이 빨간 사각형안에 자동차를 포함하지 않는다고 나올 것
- 계속해서 조금씩 옆으로 넘어감 → 이미지의 모든 곳을 슬라이드할떄까지
- 수 많은 잘려진 이미지를 컨브넷에 통과 시키는 것 → 각 위치에 대해서 0or1로 분류된다는 것
- 
- 슬라이딩 윈도를 한번 완료하면 → 더 큰 상자를 이용해서 다 슬라이드해\
- 그리고 3번쨰에는 더 큰 상자로 수행

- sliding window detection의 큰 단점은 컴퓨팅 비용이 상당히 많이 든다.
- sliding window detection 하지만 이를 컨브넷으로 해결 할 수 있음

## 4.  Convolutional Implementation Sliding Windows (C4W3L04)

![](_2019-07-24__6-9d5c9b5e-ab5f-4800-a6fc-58ef8e3ff36b.40.28.png)

![](_2019-07-24__7-c25c4cb7-bc7a-4cb1-957c-3dd8addeec7f.05.54.png)

- 마지마층을 4개의 클래스를 갖는 softmax로 출력
- 위 사진에서 400개의 벡터를 단순한 숫자로 보는 것이 아닌 → 아래와 같은 1x1x400의 형태로 생각을 하겠다 → 수학적으로 이것은 풀리컨넥티드 레이어와 같음
- 이 400개의 노드가 5 5 16차원의 필터를 갖고 있으니 → 400개의 각 값이 (5x5x 16)= 400  에 대한 임의의 선형 함수 이기 떄문에 → 이전 층에 대한 활성을 갖는다
- 위 내용과 아래 그림이 비슷한 과정임을 보여줌 ( 완전 연결층을 이용한 컨브넷)
- **즉 기존 컨브넷에서 뒷부분인 fc층을 conv층으로 바꾼 것 !!**

![](_2019-07-24__7-3dc5e0f2-8963-4176-9548-76cf85201edf.06.31.png)

- 어떻게 슬라이딩 윈도를 콘브넷으로?
- 콘브넷 입력이 14 14 3의 이미지라고하면 → 테스트세슨 16 16 3일 것 (노란색 추가)
- 레이블을 얻기위해 4번만 수행하면된다
- 그러나 이것은 이 콘브넷이 많은 계싼을 하게 해줌

- 4개의 윈도를 슬라이딩 하면서 검출하게 된다고 예시를 들어보자
- 마지막을 fc층이 아닌 conv층을 사용하면 아래처럼 4개의 윈도에 해당하는 구역이 생긴다
- **이는 컨브레이어를 4번 통과하지 않고 , 4개의 윈도에 대한 분류를 할 수 있어 계싼 비용이 줄어든다**

![](_2019-07-24__7-e5468998-5788-4181-9ab7-17b01e539e85.26.13.png)

![](_2019-07-24__7-415748c8-3a10-4a2e-964e-1ef4a3b8bf6b.26.18.png)

## C4W3L06 Intersection Over Union

![](_2019-07-24__7-9eea6521-8f31-441f-a111-7fb5fab5b0bc.33.08.png)

- 대부분 iou는 0.5로 셋팅한다
- iou가 1이라면 완전 일치 , 0이라면 쓰레기
- 교집합의 크기를 합집합의 크기로 나눈 값입니다.
- 이는 지역화와 정확도를 매핑하는 한 가지 방법입니다. 알고리즘이 물체를 올바르게 탐지하고 지역화한 횟수를 세면 됩니다. 물체가 맞게 지역화 되었는지는 IOU를 사용하면 됩니다.

## C4W3L07 Nonmax Suppression

- 여러개를 인식하는 문제(우리는 딱 한가지의 바운딩 박스가 인식하게 하고싶어)
- 여러개의 박스가 자동차를 찾았다고 할 수 있음

![](_2019-07-24__7-a060923d-f39d-43d9-8a1f-a5db6c947cf0.44.57.png)

![](_2019-07-24__7-39c7d4f2-5384-423b-9a44-279d2a081469.45.56.png)

- 그래서 iou를 계산하고 가장 큰 값만 남겨둬
- 이것이 nonmax suppression 이다.

    ![](_2019-07-24__7-c8b28b08-2da1-49ae-a9d9-fe9dd36f1f4e.47.43.png)

    - 우선 클래스가 하나이기 때문에 Pc만 있고
    - iou가 0.6보다 낮으면 버려버린다.
    - 그리고 Pc가 가장 최대인 상자를 고르고
    - 해당 바운딩 박스와의 iou를 구해서 , 높은 iou를 갖는 박스들을 제거하는 것이
    (해당 바운딩 박스 = 확률이 가장 높은것 ) → 그러므로 가장 높은 확률을 갖는 바운딩 박스와 iou를 계산했을때 높은 값이라면 → 중복될 확률이 높은 것(즉 이전 단계에서 도출된 직사각형과 많이 겹쳐서) → 중복되는 건 지우고 → 가장 큰 확률을 갖는 것을 남긴다?
    - → 바최대값 억제

![](_2019-07-24__8-d722c541-7f6b-4dc5-ae23-de52e15e52a4.11.23.png)

## 앵커 박스 (Anchor Boxes)

C4W3L08 Anchor Boxes

- 두 개 또는 일반적으로 더 많은 앵커 박스로 두 예측을 결합한다.
- 우선 쉽게 두개의 앵커박스만 사용하겠어
- 보행자의 모양이 앵커 박스2보다 앵커박스1과 더 비슷하기떄문에 → 이 8개의 숫자를 사용해서 부호화  → 노란색
- 1.pc=여기에 보행자가 있어,,
- 2.bxbybhbw=보행자를 둘러싼 박스,
- 3.c1c2c3= 이것이 보행자야
- 자동차는 앵커박스2와 비슷하기때문에 위와 비슷하게 같이 (노란색)

![](_2019-07-24__8-1a144292-fa89-4bd2-a197-2c082c35f4fa.22.06.png)

- (이전) 물체의 중심점에 있는 격자셀에 배정되었다
- (앵커박스) 각 물체는 이전과 같이 중심점이 있는 셀에 배정 → 하지만 이제는 물체의 모양과 가장 높은 iou를 갖는 격자 셀과 앵커 박스에 배정 → 그니까 2개의 앵커박스가 있으면 가장 높은 iou를 갖는 앵커박스를 찾는다
- y가 8차원인 이유는 pc, (좌표4개), 클래스(3개) = 8개

    ![](_2019-07-24__8-8992615f-8f1d-4378-95e1-b860576f1a2c.28.59.png)

![](_2019-07-24__8-d6505bf0-2f45-4c91-926e-9e793eb8a42b.32.04.png)

- 1(첫번째 벡터)_ 보행자와 자동차가 모두 있을 때 →8개8개 두개 나눠서 표현
- 2(두번쨰 백터)_ 온리 카만 있을 떄 → 없는 보행자는 0으로 나오고 모두 ?로
- (추가적으로) 3_ 만약 두개의 앵커박스가있는데 세개의 물체가 한 격자 셀에 있다면? OTL
                   4_ 만약 두개의 물체가 같은 격자 셀에 연관되고 있는 같은 앵커 박스를 갖는다면 OTL ㅋㅋㅋㅋㅋㅋ

- 앵커박스의 개수는 결정하는 머신러닝? 알고리즘? 비슷한게 있지만
- 만약 직접 고른다면 , 쉽게 발견할 것으로 예상되는 길쭉하거나 넓은 물체 모양을 선택

## YOLO Algorithm C4W3L09

![](_2019-07-24__8-e79d6dbd-9418-41b7-9f3e-22d6b33c3637.55.17.png)

- 빨간 박스는 가로가 더 긴거 같으니까 , 앵커박스 2가 더 가까울 거 같음
- 그래서 앵커박스 2의 pc가 1이고, 나머지가 0
- 지금은 앵커박스를 2개ㅏ 사용했으니 3x3x2(anchor)x8(1+4+class3) →(3,3,2,8)

- 그리고 아래 그림을 보면 100,100,3 의 이미지를 입력값으로 받아
- 컨브넷을 통과 시켜 → 결과 부피를 도출한다
- 우리의 예시에서는 (3,3,16) or (3,3,2,8) 이다

    ![](_2019-07-24__9-f98c3e03-d181-4d40-95f6-23148b37c3f6.01.25.png)

    - 0에대해서는 신경 안쓰고 (파란색)
    - 차가 나타나는 1에 대해서만 신경을 쓴다 → 그리고 차에대해 나름 정확한 바운딩 박스를 구체화 하는 숫자들도 도출될 것 (빨간색) 이게 신경망이 에측하는 방법 → 마지막으로 비-최대값 억제를 적용한다

    - 새로운 이미지로

        ![](_2019-07-24__9-cc8f5282-1df2-43cb-9646-70aa6415752c.06.29.png)

    - 각 그리드 셀에, 2개의 '예측 바운딩 박스를 준다'
    - 어떤 바운딩 박스들은 그리드 셀 밖을 나와있을 수도 있다

        ![](_2019-07-24__9-7f2d1680-1785-4604-81bb-33749abbbc58.06.37.png)

    - 다음으로 낮은 확률을 갖는 것을 제거해준다.

    ![](_2019-07-24__9-19592814-3f6b-4f8d-8d04-08e46dab1989.06.46.png)

    - 마지막으로 보행자,자동차,오토바이 세가지 클래스를 감지한다면
    - 3개의 클래스에 대해 →클래스에 대해 nonmax  ( 보행자에대해 nonmax, 차에대해 nonmax, 오토바이에대해 nonmax) →  완벽하게 검출
    - → 완벽하게 검출 → 이것이 YOLO
